# tactiq.io free youtube transcript
# No title found
# https://www.youtube.com/watch/ZYJIakkcLYw

00:00:00.000 No text
00:00:00.000 I've been building this little computer based on the 6502 processor and we had it successfully printing out hello world but that was with this
00:00:06.600 really slow clock module and so in the last video I replaced that with a one megahertz oscillator like this but when
00:00:14.099 I did that it doesn't work anymore we reset this doesn't display the message and I know a number of you who are
00:00:20.580 following along with these videos maybe you got the kit from my website so you have all the parts I know a number of you were having the same issue and I
00:00:27.060 teased a bit at the end of the last video that this is because the LCD takes a little bit of time to execute each instruction and one megahertz the
00:00:33.750 processor is just going too fast so let's see what we can do about that well what's happening is you know we
00:00:39.210 initially power up the computer and initially you can see the LCD is not initialized it defaults to this one line
00:00:45.120 mode that looks like this but when we reset the processor so it starts running our code we see that the LCD appears to
00:00:52.890 get initialized or at least it goes into this two line mode and the cursor shows up but nothing else happens and I think
00:00:59.039 that's because the very first instruction we send to the LCD is this initialization instruction that sets the interface into 8-bit mode set to two
00:01:06.600 display and selects the right font but once our code sends this instruction it takes the LCD a bit of time to actually
00:01:12.420 do the instruction you know but our code just keeps going and sending all these other instructions before the LCD is
00:01:17.850 ready and in fact I think we're sending all these instructions and the entire hello world message while the LCD is
00:01:23.820 still processing you know this first instruction up here now if we look at the data sheet for the LCD module you
00:01:29.460 can see it warns us about this and it says when an instruction is being executed for internal operation no other
00:01:34.770 instruction other than busy flag address read instruction can be executed so once we execute this first instruction here
00:01:40.920 the LCD isn't going to do anything else while it's busy and so you might think well wait a minute that you know the
00:01:46.170 cursor is showing up on the screen so doesn't that mean that the next instruction that turns the cursor on is running and honestly you know I'm not
00:01:52.860 sure maybe you know it might it might also just be that the cursor is on by default yeah if you look at the data
00:01:58.049 sheet you can see it says each of these instructions that we're doing takes 37 microseconds to execute and at 1
00:02:03.509 megahertz you know 37 microseconds is going to is going to be 37 clock cycles if you look at what we're doing to
00:02:09.060 execute each of these instructions you know we're loading something into the a register and then we're jumping down to this seedy instruction subroutine which is
00:02:15.390 down here and this sets all the right control bits or whatever it is to send the instruction well all of this code
00:02:20.879 you know if we if you look up you know the instruction cycle times for each instruction it turns out all of this code takes about 35 clock cycles and so
00:02:28.049 that means it ought to take about 35 microseconds so we're going to fast but maybe only barely
00:02:33.000 No text
00:02:33.330 now one trick yeah if you want to add just a short delay is is to put some no op instructions in here now each no op
00:02:40.379 instruction takes two clock cycles so you know if we've got five no ops or actually go ahead and put ten no ops in
00:02:46.739 here that ought to add about 20 microseconds of delay so let's see if this works I'll save this and run the
00:02:53.250 assembler I'll get the EEPROM out of the
00:03:02.910 circuit and put it into the programmer and then I'll reprogram the EEPROM and there it goes
00:03:09.200 I'll just speed this up and there it is it's done it's now where you put the EEPROM back in the circuit and power it
00:03:16.410 back up reset it again make sure it runs the program and it looks like the same
00:03:22.650 thing so what's going on so now these no ops the the entire process of sending an
00:03:28.980 instruction should now be taking about 55 clock cycles because you know I figured out that it was 35 clock cycles
00:03:34.859 just to execute the code that we had plus we added these ten no ops so that should add another 20 clock cycles so so
00:03:42.060 the whole thing is 55 clock cycles which at one megahertz would be 55 microseconds and I would think that if
00:03:47.130 the execution time of each instruction is only 37 microseconds it's oughta work but but I don't know maybe we need a
00:03:53.400 little bit more delay and of course we can add more delay by adding more no op instructions each instruction gives us
00:03:59.609 another two microseconds so we could go to 20 no ops and that'll take 40 microseconds which hopefully will be
00:04:05.639 enough because that means we do all the stuff we need to do to send an instruction then do nothing for 40
00:04:10.709 microseconds remember the datasheet says each instruction takes 37 microseconds to execute so we do nothing for 40
00:04:16.168 microseconds and then we begin to set up for the next instruction so let's try this out I'll get the EEPROM in here and
00:04:22.229 reconnect power and hit reset to start the program and that still didn't work so you know
00:04:29.820 in principle there should be some amount of delay we can have that we'll make this work right because we had it working with this slower clock and you
00:04:36.120 know of course this was like five orders of magnitude slower but still at least in principle adding some delay somewhere
00:04:41.370 oughta fix this well I won't bore you with the whole thing but I kept adding no ops and kept adding no ops until I
00:04:47.130 finally got it working and it took a lot more than I expected apparently seven hundred no out still
00:04:52.380 wasn't good enough but 750 did the trick you can see if I power it up and hit reset there we go now why I would need
00:05:01.790 750 no ops or you know 1500 microsecond delay it is not entirely clear so one
00:05:07.950 thing I noticed in the datasheet is this note that says you know to be sure that it's not in the busy state before sending an instruction also says that if
00:05:14.250 an instruction is sent without checking the busy flag the time between the first instruction and next instruction will take much longer than the instruction
00:05:20.669 time itself so it says yeah the instruction times are in table 6 here so these are the the how much time it takes to execute each instruction but if you
00:05:27.600 don't check the busy flag then it might take much longer than that and I don't know that seems weird to me you know why
00:05:33.090 would not checking the busy flag make it take longer so it seems kind of strange and the other thing I noticed is that
00:05:39.330 750 no ops will give us a 1500 microsecond delay and 1500 microseconds
00:05:44.460 is 1.5 milliseconds and so this return home instruction jumped out to me as taking about 1.5 milliseconds but you
00:05:52.050 know we're not using that instruction anywhere in our program so initially I didn't I didn't think anything of that you know we're doing function set which
00:05:58.800 is 37 microseconds display on-off control which is 37 microseconds entry
00:06:03.930 mode set which is 37 microseconds and clear display which is suspiciously missing an execution time so so maybe
00:06:11.340 this one this clear display is actually taking you know fifteen hundred microseconds you know who knows but
00:06:17.250 whatever's going on you know one thing's for sure nobody wants a program with 750 no op instructions in a row like this there's
00:06:23.070 got to be a better way and of course the better way is to do what the data she tells us we should do we should check the busy flag and wait until the LCD
00:06:28.950 isn't busy before sending it the next instruction so how does that work well one of the instructions here is to read
00:06:34.919 the busy flag and address down here at the bottom and like all the other instructions the register select is
00:06:40.160 to indicate that its instruction but the readwrite bit is set to one because we're reading you know we're not sending
00:06:45.710 an instruction to the LCD like all these other things so we're actually reading data from the from the LCD and when we
00:06:51.710 read we're gonna get an 8-bit value and that's that's what this is here and seven bits are this sort of address
00:06:57.830 counter thing but the top bit is the busy flag and that's what we're looking for
00:07:02.930 so let's write some assembly code to read that now so first things first let me get rid of all these no op instructions highlight these and jump
00:07:03.000 No text
00:07:10.160 down to the bottom of this block here and I'll just get rid of all that so there we are 750 fewer lines all right
00:07:16.970 so to read the busy flag maybe I'll make another subroutine I'll call it LCD wait and then we can call this subroutine and
00:07:22.760 it'll just wait until the LCD isn't busy and then in the return and so to read the busy flag we need to set register
00:07:28.700 select to zero and the readwrite flag to one so I'll load that into the a register just the readwrite bit is set
00:07:35.180 and I have these symbols defined up here at the very top go all the way up here so the readwrite flag is I've got a
00:07:41.810 simple set for that so back down where I was I can just say RW 2 to get just the right bit set so that's in the a
00:07:48.440 register and then if we do a store a port a that'll put that value out on port a of the 6 5 to 2 interface adapter
00:07:54.770 and port a is these first 8 bits on the left which I've really only got 3 bits
00:08:00.380 hooked up for the register select read/write and enable bits anyway this will set those bits so that we're ready to do this read operation and then like
00:08:07.520 any of the other instructions here that we've been doing to actually perform the operation we have to toggle the enable bit hi so a load a and I want to keep
00:08:14.870 everything else the same so I still want the read right fit set but then I also want the enable bit set so I'll just or
00:08:20.000 those together so both bits are set and with that in the a register we can put that out on port a of the 65 22 by doing
00:08:26.510 a store a for day again and now that toggles they name a bit high to actually do the read so now the LCD will be
00:08:33.080 outputting whether the busy flag is set or not along with this address counter thing and that'll be output on the 8
00:08:39.440 data bits which are hooked up to port B of the 65 22 here so we go back to our code we can load a from port B and
00:08:46.910 that'll read from port B which is hooked up to those data bits and put the contents into the a register except for one problem actually every
00:08:54.000 else we've been writing to port B so you know we're here restoring a to port B and down here where we're printing
00:09:00.570 character restoring a to port B so everywhere else we're writing to port B because we're writing information to the
00:09:05.820 LCD we're not you know this the first time we're actually reading something from it and to do that at the top of our program we had to set all of the pins on
00:09:12.660 port B to be output pins by by writing ones to the data Direction register for
00:09:17.760 port B well now that we want to read from port B we want to sort of turn that around at least temporarily down here in
00:09:24.600 our our new subroutine so come back down here and before you do any of this stuff I want to set the direction of Port B to
00:09:31.290 input so I want to write all zeros to the data Direction register for Port B's that'll set that as input and it will
00:09:37.860 write that to DDR B and that's the data Direction register and DDR B is just an address you know it's defined up here at
00:09:44.190 the very top as six zero zero two and in a previous video we hooked up this
00:09:49.440 interface adapter chip so it's enabled for those six zero zero whatever addresses so this will set port B as
00:09:56.130 input down here and then you know we can just copy this and at the end of whatever it is we're doing here we can
00:10:02.640 set it back to being output again so so I'll just add that down here okay so
00:10:09.450 we're setting port B to input then we are telling the LCD we want to read the busy flag and then we're toggling the
00:10:15.810 enable flag on to actually execute that read and then we're reading the the result from Port B into the a register
00:10:21.800 so once we do that we've got the busy flag in the a register and we just want to check if it's set and if it is we
00:10:28.410 want to loop back up up to the I guess up to here and just sort of keep going through this loop of all this stuff and
00:10:35.850 just keep reading it until it isn't busy anymore so how do we do that well we're gonna need some kind of conditional jump
00:10:41.730 or branch instruction or something that will that will loop back up to the the top of our subroutine if the busy flag is set but then you know continue
00:10:48.750 executing something and maybe return from the subroutine down here at the bottom if it's not set and the 6502
00:10:54.000 No text
00:10:55.920 gives us a bunch of conditional jump instructions which are all these branch instructions here you can see there's a
00:11:01.380 you know branch on carry clear branch on carry set branch if equal branch if
00:11:06.450 result - not equal plus branch on overflow clear overflow set there's a lot of different
00:11:11.860 conditional branching instructions but what do they all mean and which one can we use to branch to one part of the code if the busy flag is set from the LCD and
00:11:18.430 a different part of the code if the busy flag isn't set well the key to understanding these different instructions is that they all work off
00:11:20.000 No text
00:11:24.310 of different CPU flags so the internally in this in the 6502
00:11:29.820 there's a processor status register that stores eight bits of status and some of
00:11:35.500 these you know reflect different modes that the processor might be in but relevant to what we're doing there are a few bits that are updated by certain
00:11:41.890 instructions so the carry flag the zero flag the overflow flag and the negative
00:11:47.710 flag are all potentially updated by different instructions and if we go look at the different instructions show a
00:11:53.980 different table here somewhere there's this column out here that shows what processor status Flags register flags
00:12:00.160 are updated so for example this add with carry instruction here the the first instruction add with carry will update
00:12:06.220 the negative flag the overflow flag the zero flag and the carry flag so anytime you do in addition with this instruction
00:12:13.210 all of these flags are going to be updated based on the result of that addition like you know if you're trying to add two numbers and the result is
00:12:19.270 more than 255 the answer is not going to fit in 8 bits but the processor could set the carry flag for example to to
00:12:26.170 indicate that and then you can use a branch of carry said or a branch of carry clear instruction to do something
00:12:32.380 differently in each case now one instruction that turns out to be really useful here is the compare instruction
00:12:37.420 and what it does is basically subtract something from the a register and then ignores the results so it doesn't change
00:12:43.420 what's in the a register but it does update the status register as if it had done that subtraction so let me give you
00:12:48.940 an example you know if we did compare forty two this would compare whatever is
00:12:56.260 in the a register to forty two but really what it does is it subtracts 42 from whatever's in the a register and
00:13:02.380 doesn't do anything with the result but it will set the status register as if it had so if the a register had 42 in it
00:13:09.160 like if we did a load a 42 beforehand then this is gonna be the same thing
00:13:14.920 well this compare 42 is gonna subtract 42 from 42 which is 0 and it doesn't put
00:13:20.080 the 0 anywhere but what it does do it sets the zero flag so the zero flag would be equal to one after this compare
00:13:26.500 but then there's this branch if equal where is it there we go which will jump if the zero flag is set to one so if the
00:13:33.579 zero flag is set then it will jump and you can see why it's called branch if equal because you know this will compare
00:13:39.370 the a register to forty two and then jump if the a register equals forty two right so if we said branch if equal to
00:13:49.180 you know some address then it's going to it's going to branch to that address if they register equals forty two because
00:13:54.910 we would subtract 42 from forty two we don't do anything with the result we set the zero flag but then this branch if equal instruction looks at that zero
00:14:01.240 flag azusa that's set I better branch to that instruction instead of continuing execution so the name sort of makes
00:14:07.510 sense branch if equal after we compare something but it's useful to know that the way it really works is by simulating subtraction and then branching if that
00:14:14.709 zero flag is set but anyway back to what we're trying to do you know we've read this busy flag into the the a register
00:14:20.740 and then we want to figure out if it's set now we can't just check if the a register is zero or not because only
00:14:26.260 this one bit is the busy flag the rest of these bits are you know the address counter and you know who knows what what
00:14:31.420 they're gonna be and we don't really care so what we can do is use the the end instruction to do a bitwise and with
00:14:37.779 with the one bit that we actually care about so for example if we read this into the a register and we get you know
00:14:43.060 this you know whatever binary thing you know the busy flag is set but we don't care about all this other stuff we could end that with one zero zero zero zero
00:14:51.250 zero zero zero and then the result would just be the logical and of each bit so
00:14:56.740 if this bit and this bit are set then you know the result is going to have to have that set but for every other bit since these are all zeros you would
00:15:03.069 never have a situation where you know this bit and this bitter set because this bit will never be set so basically zeroing out all these bits except for
00:15:09.610 the top bit which is the busy flag so by anding with this value or basically zeroing out all of the bits
00:15:15.430 except the top bit which is the busy flag which means that after this now the entire value will either be zero if the
00:15:21.279 busy flag isn't set or not zero if it is and just a double check we can see that the end instruction does in fact update
00:15:27.819 the zero flag so we could use that to conditionally jump to stay in a loop until the busy flag isn't set anymore
00:15:34.000 No text
00:15:34.520 so let's do that so here after we've read the busy flag we're anding it with with one zero zero
00:15:40.490 zero just to pick out that top bit to zero out all the other bits and and then this will this and will also set the
00:15:46.130 processor is a status zero flag depending on whether the LCD is busy flag is set or not sometimes we can do a
00:15:51.500 branch if equal because branch if equal is going to look at that zero flag and we can jump back up to LCD wait
00:15:57.650 although wait a minute is this right let's think this through so we want to stay in the loop while the LCD is busy
00:16:02.870 so if the LCD is busy then anding like this to pick out the busy flag will be
00:16:07.880 nonzero so LCD busy flag a set then that means the cpu zero flag will not be set so we want to stay in the loop while the
00:16:14.930 LCD is busy so that means we want to stay in the loop while the zero flag is not set so really we want branch if not
00:16:21.860 equal since that'll branch if the zero flag is not set so there we go and I
00:16:27.350 don't know I find this a little bit confusing because the end here is picking out this this bit that we we care about but then the branch if not
00:16:33.920 equal really means we're branching if this bit is set right so maybe in this
00:16:39.440 case maybe it makes more sense to think about this as branch if not zero but anyway this ought to stay in that loop
00:16:44.780 or I guess sort of create this loop that'll just keep looping until we read the busy flag and it's not set once that
00:16:52.070 happens then we you know just need to sort of clean up down here we're already setting port B back to output but we
00:16:58.340 should also clear the enable bit so I can do that by just copying this down here since that will turn off the enable
00:17:04.910 bit and so now this ought to ensure that everything's cleaned up before we return from the subroutine so now we should be
00:17:11.209 able to use this in our LCD instruction subroutine and this is the subroutine that sends an instruction to the LCD
00:17:16.640 module that we did in previous video so before we send the instruction we could
00:17:21.890 just do a jump to subroutine LCD wait and this will you know then go up to our
00:17:26.900 LCD weight routine and wait until the busy flag isn't set before continuing with the rest of whatever it does to
00:17:32.540 actually send an instruction the one thing to be aware of is that the LCD weight subroutine we we just wrote uses
00:17:38.480 the a register right you know we're loading things into the a register here where we're reading
00:17:44.409 we're reading that busy flag into the a register so this is actually gonna be a problem because the LCD instruction
00:17:50.049 subroutine sends an instruction to the LCD but the way it works is the instruction it sends is whatever was put
00:17:55.419 in the a register before calling us up here we put something in the a register we call LCD instruction that jumps down
00:18:02.620 here to LCD instruction and we actually depend on having that thing in the a
00:18:08.799 register in order to send it as an instruction well if I'll see the instruction immediately calls LCD wait
00:18:16.059 an LCD wait clobbers what we had in the a register then that's going to be a problem so what we can do is in our LCD
00:18:22.210 wait subroutine here we can just push the value from the a register onto the stack of the beginning and then pull off
00:18:27.580 the stack into the a register at the end that way that a register will be back the way we found it since we have to be
00:18:32.860 careful here in our loop that we don't jump all the way back up to the top here and push something else onto the onto
00:18:38.470 the stack you know we only want to push one thing onto the stack of the beginning of the subroutine and then and then pull it off at the end so maybe I
00:18:44.529 need to add another label here it's like LCD busy and then here we'll jump to LCD
00:18:53.919 busy and in fact I can even move this down a bit because there's no reason to keep setting port B to input you know we
00:19:00.909 only need to do that once at the beginning and then you know we're setting it back to output here at the end so this ought to work
00:19:07.809 I think we push the a register onto the stack we set port B as input then we you
00:19:13.210 know do all this stuff to read from Port B we check if the busy flag is set and if it is we loop back up to LCD busy
00:19:20.200 here and and just keep checking and then once it's not set when you stop reading from the LCD and set port B back to
00:19:27.490 output pull the original value in the original register and then returned from
00:19:33.940 the subroutine and so we're calling that subroutine right here before we send an instruction to the LCD and maybe we
00:19:41.320 should also do it before we print the character to the LCD so anytime we're doing anything with the LCD we check to
00:19:47.110 see that it's busy or we wait I guess until it's not busy before sending it you know either an instruction or sending it a character so let's try this
00:19:54.000 No text
00:19:54.279 out I'll save it run the assembler again get the EPROM back into the programmer
00:20:00.690 I'm the assembler there it goes it's programming and I'll let this speed this up a little bit and it's done so now
00:20:08.470 let's put this EEPROM in get that one out this is the one with the new program
00:20:14.520 put that in and then I'll power this up
00:20:20.850 reset and there it goes it's working so that's awesome now at this point I'm actually curious
00:20:27.490 if this is faster or better in some way than what we had before with the 750 no ops I mean obviously aside from the
00:20:33.820 ridiculousness of the code with 750 lines of no op so I have that program with all the no ops on this other EEPROM
00:20:39.520 here and of course I have the program that we that we just wrote here that checks the busy flag on this EEPROM here
00:20:44.650 so we can sort of compare them so I put this other one back in there real quick
00:20:50.430 power this up and of course this one works too this is the one with all the
00:20:55.540 no ops and I think what we can do to kind of see how fast it's running is take a look at the enable pin on the LCD
00:21:00.580 because for each instruction or character or whatever we're sending to the LCD we're toggling that enable pin
00:21:06.070 so if we look at it we ought to be able to see sort of the timing of everything it looks like I may be bounced the
00:21:12.070 enable pin a couple times got a couple X exclamation points cuz that I guess was the last data that was on there but
00:21:17.230 anyway well reset this and so now this is set up to look at that enable pin and so I'll set the oscilloscope here to a
00:21:22.930 single shot and trigger here somewhere so it should start capturing once the enabled pin goes high so let me hit
00:21:29.170 reset and run the program and there we go you can see you can actually see the four instructions that we're sending
00:21:34.510 with the 1500 millisecond or so delay between each one actually I guess it's a little bit longer than fifteen hundred
00:21:40.270 milliseconds because the no ops are adding 1,500 milliseconds but the you know actually sending the instruction
00:21:45.340 itself is another load we figure like 35 microseconds and then I guess this stuff
00:21:50.950 out here I'm actually zoom in here I can see our instructions and then if we go all the way over here this is probably
00:21:57.070 the message itself that looks like it should match the 13 characters that we send to print our hello world message
00:22:03.100 it's okay let's compare now the the new program that checks the busy flag so I'll just connect power here get this
00:22:09.520 EEPROM out of here put the other one in power back up reset yep that's still
00:22:17.780 working but now let's retry the scope here so I'm out of here go back to single-shot mode and then I'll reset the
00:22:24.350 computer again so it reruns the program and look at that definitely it takes less time overall to run I haven't changed the scale here but let's uh you
00:22:31.250 know actually zoom in there and take a look at what's going on so I'm just guessing here but it looks like we've got our function set and then or
00:22:36.800 actually we check the busy flag and then function set then check the busy flag and then this would be display on check
00:22:44.510 the busy flag and then what was it set the increment mode and then display on and clear the screen and then it looks
00:22:52.040 like it's probably just continually checking the busy flag so so I guess it's that that clear displaying
00:22:57.620 instruction here that takes forever because then it's you know checking the busy flag checking the busy flag and so on until it gets here and then and then
00:23:04.340 here it looks like it's probably just sending the message because that's the next thing I would do and that's you know checking the busy flag between each
00:23:09.830 character so I guess I guess it really was the clear display instruction you
00:23:15.830 know because we've got you know one two three four instructions and and it's that fourth instruction that then we get
00:23:21.860 stuck in this are not stuck but we're in this loop for a while where we're checking the busy flag before we can print the message so i yeah that's I
00:23:28.400 don't know I don't know about you I think that's pretty cool to see we've got our hello world program working again and this seems like the right way
00:23:34.430 to do it really the only other thing we could do to improve this is we go back to the code this part where we actually
00:23:36.000 No text
00:23:40.490 print the message uh-hum it's kind of annoying to have each character individually sent like this and it would
00:23:47.270 be a lot better if we just had a loop that printed out the whole message and the way to do that is you know right now we're loading each character into the a
00:23:53.000 register directly and calling print care to send it to the LCD but instead of
00:23:58.190 using this load of media syntax with the hash sign here to load a character we could have the character somewhere else
00:24:03.260 in memory and load it from there so for example somewhere else in memory say you know down here I can add a label
00:24:09.890 so we'll call it message and then just put a byte which I can still represent as a character like this and then
00:24:15.500 instead of directly loading an H into the a register like we're doing up here I can do load a message and that will
00:24:24.620 load a byte from the address referred to by the label message down here so that's gonna load this H down
00:24:30.830 here and of course you know that that's not much better but the other thing I can do is instead of just having a
00:24:36.470 single bite down here is I can actually have a whole string so if I change this instead of bite to a skeezy I can put
00:24:43.250 the the whole message down here and what this does is it says at this point in memory you know referred to by this
00:24:49.220 label message sort of after this jumped loop instruction and before the you know
00:24:55.789 the LCD weight and just gonna put this string right there in our in our binary output and it's just going to insert
00:25:01.520 this string and the Z in ASCII Z means that not only we have the string in
00:25:06.649 memory but at the end of the string there'll be an extra byte that's just a 0 so actually you know let me save this
00:25:12.049 and assemble it real quick I'll run the assembler again and then do a hex dump of the output to see what's in the
00:25:18.200 assembled binary file and here you can see the message helloworld is is right in there and at the end of the message
00:25:24.919 this byte here so this would be the the LD exclamation point you can see there is a 0 null byte and then after that we
00:25:32.929 have the four eight eight nine zero zero which actually corresponds to the push a and then load a zero zero which is just
00:25:39.620 the the code that comes that comes after this so this message is here and then there's just you know push a load a zero
00:25:44.659 so it's just kind of jammed right in the middle of this code but that's fine you know because we have a jump here and
00:25:49.760 then this is the beginning of a subroutine so this isn't really in in anyone's way but we have this this
00:25:55.100 message here in it it's gonna be in our ROM it's gonna be at an address that we can refer to by this label message but
00:26:01.000 No text
00:26:01.460 anyway you know up here we've got this thing where we're loading a message and of course this is still only good just gonna load H into the a register because
00:26:07.640 a register is only one byte so just gonna load that first bite but then what we want to do is you know print that
00:26:13.159 character and then somehow load the next byte so you know I just want that like so the address of message plus one or
00:26:19.760 something like that and then this would be you know the address have message plus 2 and and so on we could do
00:26:26.419 something like that unfortunately this doesn't work written quite like this but there is a way to do it with the X
00:26:31.429 register which is sort of the the index register so if I say load a message comma X
00:26:36.980 that means use the address of message as because messenger member is pointing to some place in in ROM which has this
00:26:44.030 message so use use the address of that and then add whatever's in the X register so if we set the X to 0 up here
00:26:51.530 by doing load X 0 then if we add X here you know X is 0 this is going to be the same thing so we're just loading message
00:26:57.460 but then if we do in increment X and then load a message comma X here then
00:27:04.820 this is going to load message + 1 because X started as 0 we incremented it to 1 here and we could
00:27:11.809 sort of keep doing that right so increment X again load a message comma X
00:27:17.690 this is now going to be you know message plus 2 right because if X start to 0 we incremented it to 1 incremented 2 and we
00:27:24.500 could keep going but now we've actually got something that's a bit easier to make a loop out of because we're doing the same instructions over and over
00:27:30.110 again so what we want to do is we want to load the current character of the message into the a register you know
00:27:35.510 call the subroutine to print that character increment X and then jump back up sort of to the top of this block to
00:27:42.650 print the next character so I can just say jump print or something and then put
00:27:47.840 a label here call it print and then this will you know sort of start with the first character in our message print
00:27:54.950 that increment it and then jump back up here and and print the next character and so on and that means I can get rid
00:28:00.559 of all of this other stuff that we were using to print hello world you know character by character like that get rid of all that so now we have
00:28:07.669 our message down here hello world and we have this little block of code here that will sort of loop character by character
00:28:12.770 and print them all out the only problem is it won't actually ever stop because this just always increments X and it
00:28:19.220 always jumps back up to print and so it'll start printing hello world to the LCD but then it's going to keep going past that 0 and into you know this code
00:28:27.200 here it's actually going to be printing sort of whatever character representation it can come up with for
00:28:32.419 for this code to the LCD which you know I don't know it might look kind of interesting but it's not what we want so in order to stop printing when we get to
00:28:38.630 the end of our message we can take advantage of the fact that this ask easy thing is putting a null or a 0 byte at
00:28:44.780 the end of the message so here after we load a from from the message plus the X offset to get the next character
00:28:50.390 the message it turns out that the load a command will set the zero flag if what it loaded was a zero and that's great
00:28:56.870 because the branch if equal instruction will branch only when the zero flag is set so we could just say branch equal to
00:29:05.500 loop which will just sort of branch right down here to this loop after you know after we're done printing so if we
00:29:12.110 just loaded a zero meaning we got to the end of our message then jump out of our you know our print loop here down to
00:29:18.650 just our little infinite loop that we kind of run when we get to the end of our program so I think this ought to work you know we initialize the X
00:29:24.290 register to zero and then we go through this loop where we're incrementing X and you know printing each character in our
00:29:29.600 message until we load a null byte which tells us we got to the end of the message so let's try it out save this
00:29:34.700 and again run the assembler disconnect power and get the EEPROM back in the
00:29:40.370 programmer then this will run the programmer so there we go we're
00:29:45.380 programming that on to the EEPROM and now let's see if this works and like
00:29:53.060 that powers right up hello world there it is nine videos into this adventure and I think we finally have a whole world
00:29:59.090 program that I'm happy with and now it's pretty easy to make it say something else so you just come in here and edit
00:30:05.150 this message to say whatever we want and the thing about the LCD module it's got two lines and the way it works is
00:30:10.340 that each line you know is 16 characters long but internally each line is represented as 40 characters so if you
00:30:16.910 send it something that's longer than 40 characters character number 41 will show up on the second line so here in my
00:30:23.480 editor let's see my string starts at column you know 19 it's saying so if I go out to column 59 that'll be 40
00:30:33.110 characters into the string so I can add some more text that will appear on the second line of the display so let's try
00:30:38.360 that I'll save this and reassemble and
00:30:43.520 reprogram the EEPROM so let's put the EEPROM back in and we'll power it up
00:30:50.230 reset and there we go so at this point I'm going to officially say I'm done with this HelloWorld program though
00:30:56.960 there are definitely at least a couple more things I want to do with the 6502 computer in future videos so if that
00:31:02.120 interests you I'm sure you can figure out how to tell you tube to tell you when I release a new video and you can still get kids
00:31:07.670 with parts for any of these projects over at my website you know we've got all the parts in stock and we're still able to ship but because of the
00:31:14.090 shutdowns right now everything's taking just a little bit longer maybe even be a week or so right now but check eater net
00:31:19.550 slash shop for the latest on that and as always thanks to all my patrons your support is a big part of what enables me
00:31:25.250 to make these videos so thank you
00:31:33.980 you
